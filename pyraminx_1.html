<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pyraminx 3D Puzzle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', system-ui, sans-serif; background: #0a0a0a; overflow: hidden; }
        #c { display: block; }
        .ui { position: fixed; top: 20px; left: 20px; z-index: 100; display: flex; flex-direction: column; gap: 10px; }
        .btn {
            padding: 12px 24px; border: none; border-radius: 8px; font-size: 14px;
            font-weight: 600; cursor: pointer; transition: all 0.2s; text-transform: uppercase; letter-spacing: 1px;
        }
        .btn-p { background: linear-gradient(135deg, #00B5C9, #00AFC1); color: #fff; box-shadow: 0 4px 15px rgba(0,181,201,0.3); }
        .btn-p:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,181,201,0.4); }
        .btn-s { background: rgba(255,255,255,0.1); color: #F2E8D5; border: 1px solid rgba(255,255,255,0.2); }
        .btn-s:hover { background: rgba(255,255,255,0.15); }
        .title { position: fixed; top: 20px; right: 20px; font-size: 28px; font-weight: 700; color: #00B5C9; text-shadow: 0 0 20px rgba(0,181,201,0.5); }
        .status { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 10px 20px; background: rgba(26,26,26,0.9); border-radius: 20px; font-size: 14px; color: #F2E8D5; border: 1px solid rgba(0,181,201,0.3); }
        .info { position: fixed; bottom: 20px; right: 20px; padding: 15px; background: rgba(26,26,26,0.9); border-radius: 10px; font-size: 12px; color: #888; border: 1px solid rgba(255,255,255,0.1); }
        .info h4 { color: #00B5C9; margin-bottom: 8px; }
    </style>
</head>
<body>
    <canvas id="c"></canvas>
    <div class="ui">
        <button class="btn btn-p" id="scrambleBtn">Scramble</button>
        <button class="btn btn-p" id="solveBtn">Auto Solve</button>
        <button class="btn btn-s" id="resetBtn">Reset</button>
    </div>
    <div class="title">PYRAMINX</div>
    <div class="status" id="status">Ready</div>
    <div class="info"><h4>Controls</h4><p>Drag to rotate â€¢ Scroll to zoom</p></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
    (function() {
        const canvas = document.getElementById('c');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 8);
        
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(innerWidth, innerHeight);
        renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
        renderer.setClearColor(0x0a0a0a);
        
        // Lights
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const d1 = new THREE.DirectionalLight(0xffffff, 0.8); d1.position.set(5, 10, 5); scene.add(d1);
        const d2 = new THREE.DirectionalLight(0x00B5C9, 0.3); d2.position.set(-5, -5, -5); scene.add(d2);
        
        // Grid
        const grid = new THREE.GridHelper(30, 60, 0x00B5C9, 0x151515);
        grid.position.y = -3;
        scene.add(grid);
        
        // Pyraminx
        const pyraminx = new THREE.Group();
        scene.add(pyraminx);
        
        const COLORS = [0xee3333, 0x3366ee, 0x33bb33, 0xeecc00];
        let moveHistory = [];
        let isAnimating = false;
        
        // Tetrahedron vertices
        const size = 2;
        const h = size * Math.sqrt(2/3) * 1.5;
        const r = size / Math.sqrt(3) * 1.5;
        
        const V = [
            new THREE.Vector3(0, h, 0),
            new THREE.Vector3(0, -h/3, r * 2),
            new THREE.Vector3(-size * 1.5, -h/3, -r),
            new THREE.Vector3(size * 1.5, -h/3, -r)
        ];
        
        const FACES = [
            [0, 2, 1],
            [0, 1, 3],
            [0, 3, 2],
            [1, 2, 3]
        ];
        
        function createPyraminx() {
            while(pyraminx.children.length) pyraminx.remove(pyraminx.children[0]);
            
            // Black core tetrahedron
            const coreGeo = new THREE.BufferGeometry();
            const coreVerts = [];
            FACES.forEach(f => {
                coreVerts.push(
                    V[f[0]].x, V[f[0]].y, V[f[0]].z,
                    V[f[1]].x, V[f[1]].y, V[f[1]].z,
                    V[f[2]].x, V[f[2]].y, V[f[2]].z
                );
            });
            coreGeo.setAttribute('position', new THREE.Float32BufferAttribute(coreVerts, 3));
            coreGeo.computeVertexNormals();
            const coreMat = new THREE.MeshPhongMaterial({ color: 0x111111, side: THREE.DoubleSide });
            pyraminx.add(new THREE.Mesh(coreGeo, coreMat));
            
            // Stickers on each face
            FACES.forEach((faceVerts, faceIdx) => {
                const v0 = V[faceVerts[0]].clone();
                const v1 = V[faceVerts[1]].clone();
                const v2 = V[faceVerts[2]].clone();
                
                const e1 = new THREE.Vector3().subVectors(v1, v0);
                const e2 = new THREE.Vector3().subVectors(v2, v0);
                const normal = new THREE.Vector3().crossVectors(e1, e2).normalize();
                
                const n = 3;
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j <= i; j++) {
                        // Up triangle
                        const a0 = bary(v0, v1, v2, i, j, n);
                        const a1 = bary(v0, v1, v2, i + 1, j, n);
                        const a2 = bary(v0, v1, v2, i + 1, j + 1, n);
                        addSticker(a0, a1, a2, normal, COLORS[faceIdx]);
                        
                        // Down triangle
                        if (j < i) {
                            const b0 = bary(v0, v1, v2, i, j, n);
                            const b1 = bary(v0, v1, v2, i + 1, j + 1, n);
                            const b2 = bary(v0, v1, v2, i, j + 1, n);
                            addSticker(b0, b1, b2, normal, COLORS[faceIdx]);
                        }
                    }
                }
            });
        }
        
        function bary(v0, v1, v2, i, j, n) {
            const a = 1 - i / n;
            const b = (i - j) / n;
            const c = j / n;
            return new THREE.Vector3(
                v0.x * a + v1.x * b + v2.x * c,
                v0.y * a + v1.y * b + v2.y * c,
                v0.z * a + v1.z * b + v2.z * c
            );
        }
        
        function addSticker(p0, p1, p2, normal, color) {
            const center = new THREE.Vector3().add(p0).add(p1).add(p2).divideScalar(3);
            const shrink = 0.82;
            const s0 = p0.clone().lerp(center, 1 - shrink);
            const s1 = p1.clone().lerp(center, 1 - shrink);
            const s2 = p2.clone().lerp(center, 1 - shrink);
            
            s0.addScaledVector(normal, 0.02);
            s1.addScaledVector(normal, 0.02);
            s2.addScaledVector(normal, 0.02);
            
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute([
                s0.x, s0.y, s0.z, s1.x, s1.y, s1.z, s2.x, s2.y, s2.z
            ], 3));
            geo.computeVertexNormals();
            
            const mat = new THREE.MeshPhongMaterial({ color, side: THREE.DoubleSide, shininess: 80 });
            pyraminx.add(new THREE.Mesh(geo, mat));
        }
        
        const axes = [
            V[0].clone().normalize(),
            V[1].clone().normalize(),
            V[2].clone().normalize(),
            V[3].clone().normalize()
        ];
        
        async function animateRotation(axisIdx, dir) {
            if (isAnimating) return;
            isAnimating = true;
            
            const axis = axes[axisIdx];
            const angle = (2 * Math.PI / 3) * dir;
            const steps = 20;
            const da = angle / steps;
            
            for (let i = 0; i < steps; i++) {
                pyraminx.rotateOnWorldAxis(axis, da);
                await new Promise(r => requestAnimationFrame(r));
            }
            isAnimating = false;
        }
        
        async function scramble() {
            if (isAnimating) return;
            setStatus('Scrambling...');
            moveHistory = [];
            for (let i = 0; i < 12; i++) {
                const ax = Math.floor(Math.random() * 4);
                const dir = Math.random() < 0.5 ? 1 : -1;
                moveHistory.push({ ax, dir });
                await animateRotation(ax, dir);
            }
            setStatus('Scrambled - Click Solve');
        }
        
        async function solve() {
            if (isAnimating || !moveHistory.length) return;
            setStatus('Solving...');
            const rev = [...moveHistory].reverse();
            for (const m of rev) {
                await animateRotation(m.ax, -m.dir);
            }
            moveHistory = [];
            setStatus('Solved!');
        }
        
        function reset() {
            if (isAnimating) return;
            pyraminx.rotation.set(0, 0, 0);
            createPyraminx();
            moveHistory = [];
            setStatus('Reset');
        }
        
        function setStatus(t) { document.getElementById('status').textContent = t; }
        
        let drag = false, px = 0, py = 0;
        canvas.addEventListener('mousedown', e => { drag = true; px = e.clientX; py = e.clientY; });
        canvas.addEventListener('mousemove', e => {
            if (!drag) return;
            pyraminx.rotation.y += (e.clientX - px) * 0.01;
            pyraminx.rotation.x += (e.clientY - py) * 0.01;
            px = e.clientX; py = e.clientY;
        });
        canvas.addEventListener('mouseup', () => drag = false);
        canvas.addEventListener('mouseleave', () => drag = false);
        canvas.addEventListener('wheel', e => {
            camera.position.z = Math.max(5, Math.min(15, camera.position.z + e.deltaY * 0.01));
        });
        
        canvas.addEventListener('touchstart', e => { drag = true; px = e.touches[0].clientX; py = e.touches[0].clientY; });
        canvas.addEventListener('touchmove', e => {
            if (!drag) return;
            pyraminx.rotation.y += (e.touches[0].clientX - px) * 0.01;
            pyraminx.rotation.x += (e.touches[0].clientY - py) * 0.01;
            px = e.touches[0].clientX; py = e.touches[0].clientY;
        });
        canvas.addEventListener('touchend', () => drag = false);
        
        document.getElementById('scrambleBtn').onclick = scramble;
        document.getElementById('solveBtn').onclick = solve;
        document.getElementById('resetBtn').onclick = reset;
        
        window.addEventListener('resize', () => {
            camera.aspect = innerWidth / innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(innerWidth, innerHeight);
        });
        
        createPyraminx();
        (function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        })();
    })();
    </script>
</body>
</html>
